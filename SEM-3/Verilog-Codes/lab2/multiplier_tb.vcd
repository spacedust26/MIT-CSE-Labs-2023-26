$date
	Sat Nov 18 13:23:38 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module multiplier_tb $end
$var wire 6 ! p [5:0] $end
$var reg 3 " m [2:0] $end
$var reg 3 # q [2:0] $end
$scope module uut $end
$var wire 3 $ c1 [2:0] $end
$var wire 2 % c2 [0:1] $end
$var wire 3 & m [2:0] $end
$var wire 6 ' p [5:0] $end
$var wire 3 ( q [2:0] $end
$var wire 2 ) s [1:0] $end
$scope module stg0 $end
$var wire 1 * cin $end
$var wire 1 + cout $end
$var wire 1 , s $end
$var wire 1 - x $end
$var wire 1 . y $end
$upscope $end
$scope module stg1 $end
$var wire 1 / cin $end
$var wire 1 0 cout $end
$var wire 1 1 s $end
$var wire 1 2 x $end
$var wire 1 3 y $end
$upscope $end
$scope module stg2 $end
$var wire 1 4 cin $end
$var wire 1 5 cout $end
$var wire 1 6 s $end
$var wire 1 7 x $end
$var wire 1 8 y $end
$upscope $end
$scope module stg3 $end
$var wire 1 9 cin $end
$var wire 1 : cout $end
$var wire 1 ; s $end
$var wire 1 < x $end
$var wire 1 = y $end
$upscope $end
$scope module stg4 $end
$var wire 1 > cin $end
$var wire 1 ? cout $end
$var wire 1 @ s $end
$var wire 1 A x $end
$var wire 1 B y $end
$upscope $end
$scope module stg5 $end
$var wire 1 C cin $end
$var wire 1 D cout $end
$var wire 1 E s $end
$var wire 1 F x $end
$var wire 1 G y $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0G
0F
0E
0D
0C
0B
1A
1@
0?
0>
0=
1<
1;
0:
09
18
07
16
05
04
03
12
11
00
0/
1.
0-
1,
0+
0*
b11 )
b11 (
b1111 '
b101 &
b0 %
b0 $
b11 #
b101 "
b1111 !
$end
#20
1F
15
1D
0A
06
1>
1/
14
1C
1:
1+
10
b111 $
1<
1?
b11 %
0;
1E
0,
11
b1 )
0@
b110001 !
b110001 '
1=
1G
1-
13
1B
b111 #
b111 (
b111 "
b111 &
#40
04
0D
00
0F
0C
0/
0>
1<
05
0A
0?
0+
b0 $
0:
b0 %
11
06
b1 )
0@
0E
1,
1;
03
08
0B
0G
b110 !
b110 '
0.
0=
b1 #
b1 (
b110 "
b110 &
#60
0;
0<
01
b0 )
0,
b0 !
b0 '
02
0-
b0 #
b0 (
b101 "
b101 &
#80
